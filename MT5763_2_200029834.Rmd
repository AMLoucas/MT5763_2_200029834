---
title: "MT5763_2_200029834"
output: html_document
indent: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Abstract
<!-- executive summary -->
This project used data collected from a clinical trial that was testing a new drugs for male pattern baldness. Our aim is to compare this new drug called Luxuriant against 3 already existing drugs Placebo, Baldbegone and Skinheadnomore. To achieve our aim we will use linear modeling in the appropriate manner in combination with randomization and bootstrapping tests. Using the confidence intervals from our randomized data-sets we concluded that Luxuriant is indeed a more efficient drug than Placebo but not from the Baldbegone and Skinheadnomore. Additionally regression testing was applied to understand the relation of har growth against the age of the subject. We can observe from our regression estimates, that age was not an important factor for the hair growth length of our patient. \

## Introduction
<!-- describing the purpose of your investigation -->
The aim of our report is to identify the efficiency of the Luxuriant drug against the other already existing ones. Using the data provided that was collected from the clinical trial of the drugs, we will modify our data in teh desired format and structure to apply statistical analyses on it and answer our question. The SAS code used to achieve our desired results are included in the report with appropriate commenting of explanation. \

## Analysis Descritpion
<!-- clear account of what you did statistically as well as the data wrangling,) and why -->
#### Data Wrangling
  Our data is constructed by 8 columns and holds the age and hair growth length in inches for each drug and each patient. In our wrangling process we will break the big data set to 4 small individual ones holding the age and hair growth length in mm for only 1 drug We will then merge our tables and keep the column values (hair growth or age) that we are interested in. When merging we will add a new column to hold the value of which drug the specific row represents. This wrangling procedure will be the same for all the questions. \

#### For question 1 (Is there an effect of Luxuriant above and beyond the placebo?)
  We now have our data in the appropriate format and structure to apply our analyzes. For the first question we are only interested in hair growth of drug Luxuriant against drug Placebo. We will apply a linear model using response variable Hair growth and predictor the drug.
```
/* MT5763 INDIVIDUAL-PROJECT 1 */
/* Question 1 with Linear Regression. */

/* IMPORTING THE CSV FILE TO APPLY COMPUTATIONS */
FILENAME REFFILE '/folders/myfolders/sasuser.v94/Practical-Individual/Baldy.csv';

PROC IMPORT DATAFILE=REFFILE
	DBMS=CSV
	OUT=WORK.BALDY;
	GETNAMES=YES;
RUN;

/* KEEPING ONLY TWO COLUMNS WE INTERESTED */
DATA WORK.BALDY;
	SET WORK.BALDY;
	KEEP LUXURIANT PLACEBO;
RUN;

/* CREATING THE LUXURIANT TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA LUXURIANT;
	SET WORK.BALDY;
	GROUP = "LUXURIANT";
	LUXURIANT = LUXURIANT * 25.4;
	KEEP LUXURIANT GROUP;
	RENAME LUXURIANT = HairGrowth;
RUN;

/* CREATING THE PLACEBO TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA PLACEBO;
	SET WORK.BALDY;
	GROUP = "PLACEBO";
	PLACEBO = PLACEBO * 25.4;
	KEEP PLACEBO GROUP;
	RENAME PLACEBO = HairGrowth;
RUN;

/* SORTING BOTH TABLES BY HAIRGROWTH TO MERGE THEM */
PROC SORT DATA = WORK.LUXURIANT;
	BY HairGrowth;
RUN;
PROC SORT DATA = WORK.PLACEBO;
	BY HairGrowth;
RUN;

/* MERGE BOTH TABLES TOGETHER NOW */
DATA WORK.BALDY;
	MERGE WORK.LUXURIANT WORK.PLACEBO;
	BY HairGrowth;
RUN;


/* FIT A LINEAR MODEL USING THE GROUP AS FACTOR, TO SEE HOW GOOD A TREATMENT IS 
	OUR P-VALUE WILL CHECK IF OUR TWO MEANS ARE EQUALL. IF NOT EQUAL, THA ONE WITH 
	HIGHEST MEAN IS THE BEST TREATMENT */
PROC GLM 
	DATA = WORK.BALDY outstat=ERRORS plots = all;
	CLASS GROUP;
	MODEL HairGrowth = GROUP;
RUN;
QUIT;
```
 Once we applied our Linear model, we have noticed our assumptions are violated, this means that our p-values are uncertain and may not be valid.. For this reason we will apply a randomized test on the two hair growth means of each drug, which does not have to follow any distribution assumptions. \
  We will apply a one tail Hypothesis test on our means to obtain our desired results:
 
 * Ho: MEAN(LUXURIANT) = MEAN(PLACEBO)
 * H1: MEAN(LUXURIANT) > MEAN(PLACEBO)
```
/* QUESTION 1 */
/* QUESTION 1 WITH RANDOMISATION TEST */
/* DROPPING TABLES TO RE-CREATE THEM */

/* IMPORTING THE CSV FILE TO APPLY COMPUTATIONS */
FILENAME REFFILE '/folders/myfolders/sasuser.v94/Practical-Individual/Baldy.csv';

PROC IMPORT DATAFILE=REFFILE
	DBMS=CSV
	OUT=WORK.BALDYq1;
	GETNAMES=YES;
RUN;

/* DATA WRANGLE TO APPLY RANDOMISED TEST 
 KEEPING ONLY HAIRGROWTH VALUES FOR LUXURIANT AND PLACEBO 
 FINDING THE MEAN FOR THE TWO DIFFERENT GROUPS HAIRGROWTH 
 FINDING THE DIFFERENCE VALUE 
 COMPARING THE ORIGINAL DATA MEAN DIFFERENCE WITH RANDOMISED 
 TO CHECK IF OUR MEANS ARE EQUAL.
 RANDOMISED DATA IS CREATE ASSUMING THE MEANS ARE EQUAL. */

/*------------------------------------------------------*/
/*-------------ORIGINAL MEAN DIFFERENCE---------------- */
/*------------------------------------------------------*/

/* KEEPING ONLY TWO COLUMNS WE INTERESTED */
DATA WORK.BALDYq1;
	SET WORK.BALDYq1;
	KEEP LUXURIANT PLACEBO;
RUN;

/* CREATING THE LUXURIANT TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA LUXURIANT;
	SET WORK.BALDYq1;
	GROUP = "LUXURIANT";
	LUXURIANT = LUXURIANT * 25.4;
	KEEP LUXURIANT GROUP;
	RENAME LUXURIANT = HairGrowth;
RUN;

/* CREATING THE PLACEBO TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA PLACEBO;
	SET WORK.BALDYq1;
	GROUP = "PLACEBO";
	PLACEBO = PLACEBO * 25.4;
	KEEP PLACEBO GROUP;
	RENAME PLACEBO = HairGrowth;
RUN;

/* SORTING BOTH TABLES BY HAIRGROWTH TO MERGE THEM */
PROC SORT DATA = WORK.LUXURIANT;
	BY HairGrowth;
RUN;
PROC SORT DATA = WORK.PLACEBO;
	BY HairGrowth;
RUN;

/* MERGE BOTH TABLES TOGETHER NOW */
DATA WORK.BALDYQ1;
	MERGE WORK.LUXURIANT WORK.PLACEBO;
	BY HairGrowth;
RUN;

/* NEED TO SORT NEW TABLE BY GROUP SO MEANS CAN BE OBTAINED 
	FINDING MEAN VALUES FOR HAIRGROWTH FOR EACH GROUP */
PROC SORT DATA = WORK.BALDYQ1;
	BY GROUP;
RUN;

/* FINDING MEAN OF GROWTH HAIR FOR EACH GROUP 
	RESULT TABLE OF MEANS IS HELD IN VARIABLE "OriginalMeans" */
PROC MEANS data =WORK.BALDYQ1;
	VAR HairGrowth; 
	BY GROUP;
	OUTPUT OUT=OriginalMeans mean=; 
RUN;

/* KEEPING ONLY DATA INTERESTED FROM MEAN TABLE "OriginalMeans" */
DATA WORK.OriginalMeans;
	SET WORK.OriginalMeans;
	KEEP GROUP HairGrowth;
RUN;

/* TransposING TABLE TO GET THE DIFFERENCE OF THE TWO MEANS
	APPLYING A ONE TAIL TEST. ALTERNATIVE HYPOTHESIS:
	LUXURIANT > PLACEBO */
PROC TRANSPOSE 
	DATA= WORK.OriginalMeans 
	out = WORK.OriginalMeans;
RUN;

/* GET ORIGINAL DIFFERENCE LUXURIANT - PLACEBO (H1)*/
DATA WORK.OriginalMeans;
	SET WORK.OriginalMeans;
	DIFFERENCE=COL1-COL2;  /*GETTING DIFFERENCE */
	KEEP DIFFERENCE;
RUN;

/* REPLICATING THE VALUE TO CREATE TABLE SAME LENGTH AS RANDOMIZED DATA
	LENGHT OF RANDOMIZED 500 */
PROC SURVEYSELECT 
	data=WORK.OriginalMeans 
	out=WORK.OriginalMeans 
	seed=2345
	METHOD=urs 
	noprint 
	sampsize=1 
	outhits rep=500; 
RUN;

/* FILTERING COLUMNS TO ONE ONLY INTERESTED 
	"DIFFERENCE" HOLDS THE MEAN DIFFERENCE OF ORIGINAL DATA */
DATA WORK.OriginalMeans ;
	SET WORK.OriginalMeans ;
	KEEP DIFFERENCE;
RUN;


/*------------------------------------------------------*/
/*------------RANDOMIZING MEAN DIFFERENCE-------------- */
/*------------------------------------------------------*/

/* FUNCTION THAT DEALS WITH RANDOMIZATION 
	GETS 6 ARGUMETNS :
	(1)NLoops ->  Number of simulations to compute
	(2)Table -> Data set we will work on.
	(3)GroupVariable -> Variable holding group values.
	(4)GroupOneLabel -> Group of interest(1) "LUXURIANT"
	(5)GroupTwoLabel -> Group of interest(2) "PLACEBO"
	(6)ResponseVariable -> Value we are interested to get mean "HairGrowth"
	*/
%MACRO TwoSampRandTest(NLoops, Table, GroupVariable, GroupOneLabel, GroupTwoLabel, ResponseVariable);

/* STARTS LOOP OF RANDOMIZING NUMBEROFLOOPS TIMES */	
%DO i=1 %TO &NLoops;

	/* CREATING A DATASET HOLDING A RANDOM UNIFROM VALUE
		FOR EACH GROUP. OUR DATA IS CREATED ASSUMING THE MEANS OF
		BOT GROUPS ARE EQUAL. SO BOTH OUR GROUPS WILL HAVE SIMILAR VALUES.*/
	DATA RandomGroup;
		SET &Table
		(KEEP=&GroupVariable); /* ONLY GROUP COLUMN KEEP */
		RandomIndex=rand('uniform'); /* RANDOM UNIFORM NUMBER COLUMN CREATED */
	RUN;
	
	/* SORTS THE DATA SET BY THE RANDOM UNIFORM NUMBERS GENERATED 
		TO SORT THE TABLE IN A RANDOM ORDER AND SHUFFLE THE HAIRGROWTH VALUES
		TO DIFFERENT GROUPS. CHANGING THE VALUES OF HAIRGRWOTH FOR EACH GROUP
		BETWEEN THEM RANDOMLY TO DISTRIBUTE A RANDOM EQUAL GROUPS.*/
	PROC SORT 
		data=RandomGroup 
		out=RandomGroup;
		by RandomIndex;
	RUN;

	/* MERGING RANDOM GROUPS WITH REAL GROUPS */
	DATA WorkingData;
		merge RandomGroup(keep=&GroupVariable) &Table(drop=&GroupVariable);
	RUN;

	/* BREAKING THE MERGED TABLE TO 2 INDIVIDUAL ONES.
		EACH TABLE CORRESPONFING TO ITS APPROPRIATE GROUP*/
		
	DATA WORK.RandomGroup1;
		SET WORK.WorkingData;
		WHERE &GroupVariable=&GroupOneLabel;
	DATA WORK.RandomGroup2;
		SET WorkingData;
		WHERE &GroupVariable=&GroupTwoLabel;
	RUN;
	
	/* GETTING THE MEAN OF HAIRGWOTH FROM GROUP 1. */
	PROC MEANS 
		data=RandomGroup1 noprint;
		var &ResponseVariable;
		output out=GroupOneMean mean=mean;
	RUN;

	/* GETTING THE MEAN OF HAIRGWOTH FROM GROUP 2. */
	PROC MEANS 
		data=RandomGroup2 noprint;
		var &ResponseVariable;
		output out=GroupTwoMean mean=mean;
	RUN;
	
	/* _NULL_ INDICATES THAT DATASET WILL BE DELETED ONCE USED.
	 	symput('GroupOneMean', mean) -> CREATES A MACRO VARIABLE CALLED
	 	"GroupOneMean" THA WILL HOLD THE MEAN FROM GROUP 1 */
	DATA _NULL_;
		SET GroupOneMean;
		CALL symput('GroupOneMean', mean);
	RUN;
	
	/* DOING THE SAME AS ABOVE BUT OBTAINING GROUP 2 MEAN. */
	DATA _NULL_;
		SET GroupTwoMean;
		CALL symput('GroupTwoMean', mean);
	RUN;

	/* OBTAINING THE DIFFERENCE OF THE TWO MEANS. */
	DATA LoopDifference;
		RandomisedMean=&GroupOneMean-&GroupTwoMean;
	RUN;

	/* TABLE THAT WILL HOLD THE SAMPLE MEAN DIFFERENCE OF ALL THE SIMULATION SAMPLE DATA */
	DATA FinalResultRandomised;
		/* IF FIRST RUN OF LOOP PUT THE "LoopDifference" AS FIRST ROW. */
		%IF &i=1 %THEN %DO;
			set LoopDifference;
		%END;
		/* IF NOT FIRST RUN APPEND "LoopDifference" ON THE ALREADY EXISTING TABLE */
		%ELSE %DO;
			SET FinalResultRandomised LoopDifference;
		%END;
	RUN;
	%END;
%MEND;

%TwoSampRandTest(NLoops=500, Table=WORK.BALDYQ1, GroupVariable=GROUP, GroupOneLabel="LUXURIANT", GroupTwoLabel="PLACEBO", ResponseVariable=HairGrowth);

/* JOIN THE RANDOMISED MEANS WITH THE ORIGINAL DIFFERENT MEANS
	SIDE BY SIDE SO WE CAN FIND THE PROPORTION WE ARE INTERESTED IN.*/
DATA FinalResultRandomised;
	MERGE FinalResultRandomised WORK.OriginalMeans;
RUN;

/* FILTER THE ROWS TO KEEP THE ONES THE RANDOMISED MEANS IS LARGER 
	THAN THE ACTUAL DIFFERENT MEAN. IF ITS ABOUT HALF OD THE ACTUAL LENGTH
	250 THEN THIS INDICATES OUR MEANS ARE EQUAL.*/
DATA HypothesisResult;
	SET FinalResultRandomised;
	WHERE RandomisedMean >= DIFFERENCE; 
RUN;
```
  Using our samples means and obtaining our proportional values, we conclude that Luxuriant is indeed a more efficient drug than placebo. \
 
 **For Question 2** \

  To accomplish questions 2 we will apply the same wrangling strategy as in question 1. We will firstly plot our data for our 3 groups in a box-plot. After we will apply a bootstrap algorithm on the 3 groups data to obtain confidence intervals of where the true mean lies for each group. We will compare our values and obtain our results. \
```
/* MT5763 */
/* INDIVIDUAL PROJECT-1 */
/* QUESTION 2 WITH BOOTSTRAPPING CI FOR A MEAN */

/* IMPORTING THE BALDY CSV FILE DATASET */
FILENAME REFFILE '/folders/myfolders/sasuser.v94/Practical-Individual/Baldy.csv';

PROC IMPORT DATAFILE=REFFILE
	DBMS=CSV
	OUT=WORK.BALDYq2;
	GETNAMES=YES;
RUN;

PROC CONTENTS DATA=WORK.BALDYq2; 
RUN;

/* KEEPING ONLY 3 COLUMNS WE INTERESTED */
DATA WORK.BALDYq2;
	SET WORK.BALDYq2;
	KEEP LUXURIANT BALDBEGONE SKINHEADNOMORE;
RUN;

/* CREATING THE LUXURIANT TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA WORK.LUXURIANT;
	SET WORK.BALDYq2;
	GROUP = "LUXURIANT";
	LUXURIANT = LUXURIANT * 25.4;
	KEEP LUXURIANT GROUP;
	RENAME LUXURIANT = HairGrowth;
RUN;

/* CREATING THE BALDBEGONE TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA WORK.BALDBEGONE;
	SET WORK.BALDYq2;
	GROUP = "BALDBEGONE";
	BALDBEGONE = BALDBEGONE * 25.4;
	KEEP BALDBEGONE GROUP;
	RENAME BALDBEGONE = HairGrowth;
RUN;

/* CREATING THE SKINHEADNOMORE TABLE 
	CONVERTING THE INCHES TO MM FOR HAIRGROWTH
	PUTTING COLUMN GROUP TO SHOW WHICH GROUP VALUE REPRESENTS */
DATA WORK.SKINHEADNOMORE;
	SET WORK.BALDYq2;
	GROUP = "SKINHEADNOMORE";
	SKINHEADNOMORE = SKINHEADNOMORE * 25.4;
	KEEP SKINHEADNOMORE GROUP;
	RENAME SKINHEADNOMORE = HairGrowth;
RUN;

/* WE WILL PLOT A BOXPLOT OF OUR 3 DATASETS TO SEE A SMALL SUMMARY */
/* WE NEED TO SORT ALL SORT EACH INDIVIDUAL TABLE GROUP. SO WE CAN MERGE */
/* THEM USING THE GROUP ATTRIBUTE AND PLOT A BOXPLOT FOR EACH GROUP SIDE-BY-SIDE */

/* SORTING THE TABLES */
PROC SORT DATA = WORK.LUXURIANT;
	BY GROUP;
RUN;
PROC SORT DATA = WORK.BALDBEGONE;
	BY GROUP;
RUN;
PROC SORT DATA = WORK.SKINHEADNOMORE;
	BY GROUP;
RUN;

/* MERGE THE TABLES */
DATA WORK.BOXPLOT;
	MERGE WORK.LUXURIANT WORK.BALDBEGONE WORK.SKINHEADNOMORE;
	BY GROUP;
RUN;

DATA WORK.BOXPLOT;
	SET WORK.BOXPLOT;
	GROUP_C = GROUP;
RUN;

/* PLOT THE BOXPLOT FOR ALL THE GROUPS SIDE BY SIDE */
PROC BOXPLOT data=WORK.BOXPLOT;
   PLOT HairGrowth*GROUP;
RUN;

/* MACRO FUNCTION THAT USES BOOTSTRAPPING TO OBTAIN THE CI OF
	HAIRGROWTH ON OUR GROUP OF INTEREST 
	TAKES 1 ARGUMENT:
		TABLE -> TABLE HOLDING THE HAIRGROWTH OF GROUP WE ARE INTERESTED. */
%MACRO BootCI(TABLE);
	/* BOOTSTRAP OUR TABLES TO OBTAIN CI FOR EACH TABLES MEANS. */
	PROC SURVEYSELECT 
		data=&TABLE /* USING THIS DATA FILE */
		out=WORK.BOOT /* RESULTS WILL BE OUTPUTED IN THIS FILE */
	 	seed=5763 /* TO MAKE CODE REPRODUCIBLE */
	 	/* USE A RANDOM UNIFORM DISTRIBUTION, EACH SIMULATION 100 SAMPLE AND 500 SIMULATIONS */
	  	METHOD=urs noprint sampsize=100 outhits rep=500;
	RUN;
	
	PROC UNIVARIATE 
		data=WORK.BOOT noprint; 
		VAR HairGrowth;
		/* GETS MEAN FOR EACH SIMULATION. 500 SIMULATIONS */
		/* EACH REPLICATE ID CORRESPONDS TO THE SIMULATION IT WAS CALCULATED. */
		/* BY FUNCTION ALLOWS TO FIND THE MEAN OF EACH SIMULATION */
	    BY replicate;
		OUTPUT out=WORK.BOOTMEAN mean=MEAN;
	RUN;
	
	/* GET THE CI OF 95% FOR OUR SPECIFIC GROUP */
	PROC UNIVARIATE 
		data=WORK.BOOTMEAN;
		VAR MEAN;
	    OUTPUT out=WORK.BOOTCI pctlpts=2.5, 97.5 pctlpre=CI; /* 95% CI */
	RUN;
	
	
	/* WE PLOT OUR MEAN DATA IN A HISTOGRAM TO VIEW THE CI */  
	PROC SGPLOT data = WORK.BOOTMEAN;
		TITLE "HISTOGRAM OF &TABLE HAIRGROWTH MEANS";
		HISTOGRAM MEAN;
	RUN;
	TITLE;
%MEND;

/* CALLING BOOTSTRAPPING FUNCTION FOR EACH INDIVIDUAL GROUP */
%BootCI(WORK.LUXURIANT);
%BootCI(WORK.BALDBEGONE);
%BootCI(WORK.SKINHEADNOMORE);
```

 *For Question 3* \
 

```

```
 \

```

```
 \

```

```



## Results
<!-- results clearly explained and presented (includes data visualization-->

#### Is there an effect of Luxuriant above and beyond the placebo
Yes.
![Box-Plot of Luxuriant vs Placebo Hair Growth in MM Length](BOXPLOTS/Q1-BOXPLOT.png)
#### Is Luxuriant more effective than the existing treatments on the market
No.
![Boxplot comparing all 3 drugs in terms of hair growth in mm.](BOXPLOTS/Q2-BOXPLOT.jpeg)

![Histogram of sample means simulated for Luxuriant data to pull 95% CI.](HISTOGRAMS/Q2-HISTOGRAM(1).png)

![Histogram of sample means simulated for Balbdegone data to pull 95% CI.](HISTOGRAMS/Q2-HISTOGRAM(2).png)

![Histogram of sample means simulated for Skinheadnomore data to pull 95% CI.](HISTOGRAMS/Q2-HISTOGRAM(3).png)

#### Is age relevant to any effect?


## Conclusions
<!-- conclusions along with criticisms of the design if any -->


